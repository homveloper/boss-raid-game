package wrapper

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"sync"

	"tictactoe/luvjson/common"
	"tictactoe/luvjson/crdt"
	"tictactoe/luvjson/crdtpatch"
)

// CRDTDocument wraps a CRDT document and provides methods to work with user-defined structs.
type CRDTDocument struct {
	doc           *crdt.Document
	sessionID     common.SessionID
	rootID        common.LogicalTimestamp
	mu            sync.RWMutex
	lastJSONPatch []byte // Last JSON Patch (RFC6902) generated by UpdateStruct
}

// NewCRDTDocument creates a new CRDT document wrapper with the given session ID.
func NewCRDTDocument(sessionID common.SessionID) *CRDTDocument {
	doc := crdt.NewDocument(sessionID)

	// Create a root object directly
	rootID := doc.NextTimestamp()
	rootObj := crdt.NewLWWObjectNode(rootID)
	doc.AddNode(rootObj)

	// Get the root node
	rootNode := doc.Root()

	// Set the root value to the new object
	if rootLWW, ok := rootNode.(*crdt.RootNode); ok {
		rootLWW.NodeValue = rootObj
	} else if rootLWW, ok := rootNode.(*crdt.LWWValueNode); ok {
		rootLWW.SetValue(rootID, rootObj)
	} else {
		panic(fmt.Sprintf("unexpected root node type: %T", rootNode))
	}

	// Initialize the document with an empty map
	cd := &CRDTDocument{
		doc:       doc,
		sessionID: sessionID,
		rootID:    rootID,
	}

	// Verify that the document view is a map
	view, err := doc.View()
	if err != nil {
		panic(fmt.Sprintf("Failed to get document view: %v", err))
	}

	_, ok := view.(map[string]interface{})
	if !ok {
		panic("Document view is not a map")
	}

	return cd
}

// FromStruct initializes the CRDT document from a struct.
// The data parameter must be a pointer to a struct.
func (cd *CRDTDocument) FromStruct(data interface{}) error {
	cd.mu.Lock()
	defer cd.mu.Unlock()

	// Check if data is a pointer
	dataValue := reflect.ValueOf(data)
	if dataValue.Kind() != reflect.Ptr || dataValue.IsNil() {
		return fmt.Errorf("data must be a non-nil pointer to a struct")
	}

	// Check if data points to a struct
	dataElem := dataValue.Elem()
	if dataElem.Kind() != reflect.Struct {
		return fmt.Errorf("data must be a pointer to a struct, got pointer to %v", dataElem.Kind())
	}

	// Convert struct to map
	jsonData, err := json.Marshal(data)
	if err != nil {
		return fmt.Errorf("failed to marshal struct: %w", err)
	}

	var dataMap map[string]interface{}
	if err := json.Unmarshal(jsonData, &dataMap); err != nil {
		return fmt.Errorf("failed to unmarshal to map: %w", err)
	}

	// Create a patch to set all fields
	patchID := cd.doc.NextTimestamp()
	p := crdtpatch.NewPatch(patchID)

	// Add operations for each field
	for key, value := range dataMap {
		// Create a constant node for the value
		valueID := cd.doc.NextTimestamp()
		valueOp := &crdtpatch.NewOperation{
			ID:       valueID,
			NodeType: common.NodeTypeCon,
			Value:    value,
		}
		p.AddOperation(valueOp)

		// Create an insert operation to add the field to the root object
		insOp := &crdtpatch.InsOperation{
			ID:       cd.doc.NextTimestamp(),
			TargetID: cd.rootID,
			Value: map[string]interface{}{
				key: value,
			},
		}
		p.AddOperation(insOp)
	}

	// Apply the patch
	if err := p.Apply(cd.doc); err != nil {
		return fmt.Errorf("failed to apply patch: %w", err)
	}

	return nil
}

// ToStruct converts the CRDT document to a struct.
// The result parameter must be a pointer to a struct.
func (cd *CRDTDocument) ToStruct(result interface{}) error {
	cd.mu.RLock()
	defer cd.mu.RUnlock()

	// Check if result is a pointer
	resultValue := reflect.ValueOf(result)
	if resultValue.Kind() != reflect.Ptr || resultValue.IsNil() {
		return fmt.Errorf("result must be a non-nil pointer to a struct")
	}

	// Check if result points to a struct
	resultElem := resultValue.Elem()
	if resultElem.Kind() != reflect.Struct {
		return fmt.Errorf("result must be a pointer to a struct, got pointer to %v", resultElem.Kind())
	}

	// Get the document view
	view, err := cd.doc.View()
	if err != nil {
		return fmt.Errorf("failed to get document view: %w", err)
	}

	// Convert view to JSON
	jsonData, err := json.Marshal(view)
	if err != nil {
		return fmt.Errorf("failed to marshal view: %w", err)
	}

	// Unmarshal JSON to struct
	if err := json.Unmarshal(jsonData, result); err != nil {
		return fmt.Errorf("failed to unmarshal to struct: %w", err)
	}

	return nil
}

// UpdateField updates a single field in the CRDT document.
func (cd *CRDTDocument) UpdateField(fieldPath string, value interface{}) error {
	cd.mu.Lock()
	defer cd.mu.Unlock()

	// Create a patch to update the field
	patchID := cd.doc.NextTimestamp()
	p := crdtpatch.NewPatch(patchID)

	// Create a constant node for the value
	valueID := cd.doc.NextTimestamp()
	valueOp := &crdtpatch.NewOperation{
		ID:       valueID,
		NodeType: common.NodeTypeCon,
		Value:    value,
	}
	p.AddOperation(valueOp)

	// Create an insert operation to update the field
	// For now, we only support top-level fields
	insOp := &crdtpatch.InsOperation{
		ID:       cd.doc.NextTimestamp(),
		TargetID: cd.rootID,
		Value: map[string]interface{}{
			fieldPath: value,
		},
	}
	p.AddOperation(insOp)

	// Apply the patch
	if err := p.Apply(cd.doc); err != nil {
		return fmt.Errorf("failed to apply patch: %w", err)
	}

	return nil
}

// UpdateStruct updates the CRDT document from a struct, detecting changes.
// The data parameter must be a pointer to a struct.
// Returns the CRDT patch that was applied to the document.
func (cd *CRDTDocument) UpdateStruct(data interface{}) ([]byte, error) {
	cd.mu.Lock()
	defer cd.mu.Unlock()

	// Check if data is a pointer
	dataValue := reflect.ValueOf(data)
	if dataValue.Kind() != reflect.Ptr || dataValue.IsNil() {
		return nil, fmt.Errorf("data must be a non-nil pointer to a struct")
	}

	// Check if data points to a struct
	dataElem := dataValue.Elem()
	if dataElem.Kind() != reflect.Struct {
		return nil, fmt.Errorf("data must be a pointer to a struct, got pointer to %v", dataElem.Kind())
	}

	// Get current view
	currentView, err := cd.doc.View()
	if err != nil {
		return nil, fmt.Errorf("failed to get current view: %w", err)
	}

	// Create a temporary struct to hold the current view
	tempStruct := reflect.New(reflect.TypeOf(data).Elem()).Interface()

	// Convert the current view to the temporary struct
	currentJSON, err := json.Marshal(currentView)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal current view: %w", err)
	}

	if err := json.Unmarshal(currentJSON, tempStruct); err != nil {
		return nil, fmt.Errorf("failed to unmarshal to temporary struct: %w", err)
	}

	// Generate JSON Patch (RFC6902)
	jsonPatchData, err := GenerateJSONPatch(tempStruct, data)
	if err != nil {
		return nil, fmt.Errorf("failed to generate JSON Patch: %w", err)
	}

	// Store the JSON Patch for later use
	cd.lastJSONPatch = jsonPatchData

	// Parse the JSON Patch
	var jsonPatch JSONPatch
	if err := json.Unmarshal(jsonPatchData, &jsonPatch); err != nil {
		return nil, fmt.Errorf("failed to unmarshal JSON Patch: %w", err)
	}

	// If there are no operations, return early
	if len(jsonPatch) == 0 {
		return nil, nil
	}

	// Convert JSON Patch to changes
	changes, err := JSONPatchToChanges(jsonPatch)
	if err != nil {
		return nil, fmt.Errorf("failed to convert JSON Patch to changes: %w", err)
	}

	// Create a CRDT patch for the changes
	patchID := cd.doc.NextTimestamp()
	p := crdtpatch.NewPatch(patchID)

	// Add operations for each change
	for _, change := range changes {
		switch change.Type {
		case ChangeTypeCreate, ChangeTypeUpdate:
			// Create a constant node for the value
			valueID := cd.doc.NextTimestamp()
			valueOp := &crdtpatch.NewOperation{
				ID:       valueID,
				NodeType: common.NodeTypeCon,
				Value:    change.NewValue,
			}
			p.AddOperation(valueOp)

			// Create an insert operation to update the field
			// For now, we only support top-level fields
			parts := strings.Split(change.Path, ".")
			if len(parts) == 1 {
				insOp := &crdtpatch.InsOperation{
					ID:       cd.doc.NextTimestamp(),
					TargetID: cd.rootID,
					Value: map[string]interface{}{
						parts[0]: change.NewValue,
					},
				}
				p.AddOperation(insOp)
			} else {
				// For nested fields, we need to navigate to the parent object
				return nil, fmt.Errorf("nested fields are not fully supported yet: %s", change.Path)
			}

		case ChangeTypeDelete:
			// Create a delete operation
			// For now, we only support top-level fields
			parts := strings.Split(change.Path, ".")
			if len(parts) == 1 {
				delOp := &crdtpatch.DelOperation{
					ID:       cd.doc.NextTimestamp(),
					TargetID: cd.rootID,
					Key:      parts[0],
				}
				p.AddOperation(delOp)
			} else {
				// For nested fields, we need to navigate to the parent object
				return nil, fmt.Errorf("nested fields are not fully supported yet: %s", change.Path)
			}
		}
	}

	// Apply the patch
	if err := p.Apply(cd.doc); err != nil {
		return nil, fmt.Errorf("failed to apply patch: %w", err)
	}

	// Convert the patch to JSON
	patchData, err := json.Marshal(p)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal patch: %w", err)
	}

	return patchData, nil
}

// ApplyPatch applies a JSON CRDT Patch to the document.
// The patch data should be a []byte representation of a JSON CRDT patch.
// The default format is verbose.
func (cd *CRDTDocument) ApplyPatch(patchData []byte) error {
	cd.mu.Lock()
	defer cd.mu.Unlock()

	// Create a new patch
	p := crdtpatch.NewPatch(common.LogicalTimestamp{})

	// Parse the patch
	if err := json.Unmarshal(patchData, p); err != nil {
		return fmt.Errorf("failed to parse patch: %w", err)
	}

	// Apply the patch
	if err := p.Apply(cd.doc); err != nil {
		return fmt.Errorf("failed to apply patch: %w", err)
	}

	return nil
}

// GetPatch creates a JSON CRDT Patch from the document.
func (cd *CRDTDocument) GetPatch() ([]byte, error) {
	cd.mu.RLock()
	defer cd.mu.RUnlock()

	// Create a patch with the current timestamp
	patchID := cd.doc.NextTimestamp()
	p := crdtpatch.NewPatch(patchID)

	// Get the document view
	view, err := cd.doc.View()
	if err != nil {
		return nil, fmt.Errorf("failed to get document view: %w", err)
	}

	// Convert the view to a map
	viewMap, ok := view.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("document view is not a map")
	}

	// Add operations for each field in the view
	for key, value := range viewMap {
		// Create a constant node for the value
		valueID := cd.doc.NextTimestamp()
		valueOp := &crdtpatch.NewOperation{
			ID:       valueID,
			NodeType: common.NodeTypeCon,
			Value:    value,
		}
		p.AddOperation(valueOp)

		// Create an insert operation to add the field to the root object
		insID := cd.doc.NextTimestamp()
		insOp := &crdtpatch.InsOperation{
			ID:       insID,
			TargetID: cd.rootID,
			Value: map[string]interface{}{
				key: value,
			},
		}
		p.AddOperation(insOp)
	}

	// Convert the patch to JSON
	return json.Marshal(p)
}

// GetJSONPatch returns the last JSON Patch (RFC6902) generated by UpdateStruct.
func (cd *CRDTDocument) GetJSONPatch() ([]byte, error) {
	cd.mu.RLock()
	defer cd.mu.RUnlock()

	if cd.lastJSONPatch == nil {
		return nil, fmt.Errorf("no JSON Patch available")
	}

	return cd.lastJSONPatch, nil
}

// GetRootID returns the root ID of the document.
func (cd *CRDTDocument) GetRootID() common.LogicalTimestamp {
	cd.mu.RLock()
	defer cd.mu.RUnlock()

	return cd.rootID
}

// SetRootID sets the root ID of the document.
func (cd *CRDTDocument) SetRootID(rootID common.LogicalTimestamp) {
	cd.mu.Lock()
	defer cd.mu.Unlock()

	cd.rootID = rootID
}

// InitRootNode initializes the root node of the document with the given ID.
func (cd *CRDTDocument) InitRootNode(rootID common.LogicalTimestamp) error {
	cd.mu.Lock()
	defer cd.mu.Unlock()

	// Update the root ID
	cd.rootID = rootID

	// Reset the document
	cd.doc = crdt.NewDocument(cd.sessionID)

	// Create a root object with the given ID
	rootObj := crdt.NewLWWObjectNode(rootID)
	cd.doc.AddNode(rootObj)

	// Get the root node
	rootNode := cd.doc.Root()

	// Set the root value to the new object
	if rootLWW, ok := rootNode.(*crdt.RootNode); ok {
		rootLWW.NodeValue = rootObj
	} else if rootLWW, ok := rootNode.(*crdt.LWWValueNode); ok {
		rootLWW.SetValue(rootID, rootObj)
	} else {
		return fmt.Errorf("unexpected root node type: %T", rootNode)
	}

	return nil
}

// ApplyJSONPatch applies a JSON Patch (RFC6902) to the document.
func (cd *CRDTDocument) ApplyJSONPatch(jsonPatchData []byte) error {
	cd.mu.Lock()
	defer cd.mu.Unlock()

	// Get the current view
	currentView, err := cd.doc.View()
	if err != nil {
		return fmt.Errorf("failed to get current view: %w", err)
	}

	// Create a temporary struct to hold the current view
	// For simplicity, we'll use a map[string]interface{}
	var tempMap map[string]interface{}

	// Convert the current view to the temporary map
	currentJSON, err := json.Marshal(currentView)
	if err != nil {
		return fmt.Errorf("failed to marshal current view: %w", err)
	}

	if err := json.Unmarshal(currentJSON, &tempMap); err != nil {
		return fmt.Errorf("failed to unmarshal to temporary map: %w", err)
	}

	// Parse the JSON Patch
	var jsonPatch JSONPatch
	if err := json.Unmarshal(jsonPatchData, &jsonPatch); err != nil {
		return fmt.Errorf("failed to unmarshal JSON Patch: %w", err)
	}

	// Convert JSON Patch to changes
	changes, err := JSONPatchToChanges(jsonPatch)
	if err != nil {
		return fmt.Errorf("failed to convert JSON Patch to changes: %w", err)
	}

	// Create a CRDT patch for the changes
	patchID := cd.doc.NextTimestamp()
	p := crdtpatch.NewPatch(patchID)

	// Add operations for each change
	for _, change := range changes {
		switch change.Type {
		case ChangeTypeCreate, ChangeTypeUpdate:
			// Create a constant node for the value
			valueID := cd.doc.NextTimestamp()
			valueOp := &crdtpatch.NewOperation{
				ID:       valueID,
				NodeType: common.NodeTypeCon,
				Value:    change.NewValue,
			}
			p.AddOperation(valueOp)

			// Create an insert operation to update the field
			// For now, we only support top-level fields
			parts := strings.Split(change.Path, ".")
			if len(parts) == 1 {
				insOp := &crdtpatch.InsOperation{
					ID:       cd.doc.NextTimestamp(),
					TargetID: cd.rootID,
					Value: map[string]interface{}{
						parts[0]: change.NewValue,
					},
				}
				p.AddOperation(insOp)
			} else {
				// For nested fields, we need to navigate to the parent object
				return fmt.Errorf("nested fields are not fully supported yet: %s", change.Path)
			}

		case ChangeTypeDelete:
			// Create a delete operation
			// For now, we only support top-level fields
			parts := strings.Split(change.Path, ".")
			if len(parts) == 1 {
				delOp := &crdtpatch.DelOperation{
					ID:       cd.doc.NextTimestamp(),
					TargetID: cd.rootID,
					Key:      parts[0],
				}
				p.AddOperation(delOp)
			} else {
				// For nested fields, we need to navigate to the parent object
				return fmt.Errorf("nested fields are not fully supported yet: %s", change.Path)
			}
		}
	}

	// Apply the patch
	if err := p.Apply(cd.doc); err != nil {
		return fmt.Errorf("failed to apply patch: %w", err)
	}

	// Store the JSON Patch for later use
	cd.lastJSONPatch = jsonPatchData

	return nil
}
